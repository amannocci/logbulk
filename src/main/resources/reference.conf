setting {
}

input {
  # tcp {
  #   delimiter = "\n"
  #   host = "0.0.0.0"
  #   port = 8080
  #   dispatch = "app-route"
  #   fallback = "fallback-route"
  #   worker = false
  # }

  # mysql {
  #   host = ""
  #   port = 3306
  #   maxPoolSize = 1
  #   username = ""
  #   password = ""
  #   database = ""
  #   charset = ""
  #   queryTimeout = ""
  #   nonEmpty = false
  #   parameters {
  #     id = 0
  #     limit = 1000
  #   }
  #   order = [
  #     "id",
  #     "limit"
  #   ]
  #   track = "id"
  #   dispatch = "app-route"
  #   fallback = "fallback-route"
  #   worker = false
  # }

  # rabbitmq {
  #   user = ""
  #   password = ""
  #   hosts = [""]
  #   port = 1024
  #   virtualHost = ""
  #   ssl = false
  #   queue = ""
  #   autoAck = false
  #   connectionTimeout = 60
  #   interval = 1
  #   intervalMax = 60
  #   maxAttempts = -1
  #   dispatch = "app-route"
  #   fallback = "fallback-route"
  #   worker = false
  # }

  # exec {
  #   command = ""
  #   interpreter = "/bin/sh"
  #   arguments = "-c"
  #   interval = 1
  #   dispatch = "app-route"
  #   fallback = "fallback-route"
  #   worker = false
  # }

  # heartbeat {
  #   message = ""
  #   interval = 1
  #   dispatch = "app-route"
  #   fallback = "fallback-route"
  #   worker = false
  # }
}

transform {
  # metric {
  #   mailbox = 1000
  #   instance = 1
  #   fallback = "fallback-route"
  #   worker = false
  # }

  # limiter {
  #   limit = 1
  #   mailbox = 1000
  #   instance = 1
  #   fallback = "fallback-route"
  #   worker = false
  # }

  # regex {
  #   columns = {}
  #   field = ""
  #   pattern = ""
  #   nullable = true
  #   mailbox = 1000
  #   instance = 1
  #   fallback = "fallback-route"
  #   worker = false
  # }

  # grok {
  #   path = "/path/to/pattern"
  #   field = "message"
  #   format = "%{GREEDYDATA:message}"
  #   mailbox = 1000
  #   instance = 1
  #   fallback = "fallback-route"
  #   worker = false
  # }

  # json {
  #   field = ""
  #   mailbox = 1000
  #   instance = 1
  #   fallback = "fallback-route"
  #   worker = false
  # }

  # mutate {
  #   remove = []
  #   rename = {}
  #   strip = []
  #   uppercase = []
  #   lowercase = []
  #   mask = ""
  #   unmask = ""
  #   join = {}
  #   update = {}
  #   convert = {
  #     convertInt = "integer"
  #     convertFloat = "float"
  #     convertString = "string"
  #   }
  #   mailbox = 1000
  #   instance = 1
  #   fallback = "fallback-route"
  #   worker = false
  # }
}

output {
  # elasticsearch {
  #   hosts = [
  #   ]
  #   bulk = 1000
  #   flush = 10
  #   type = "type"
  #   index = "index"
  #   mailbox = 1000
  #   instance = 1
  #   fallback = "fallback-route"
  #   worker = false
  # }

  # mongo {
  #   collection = ""
  #   database = ""
  #   uri = ""
  #   bulk = 1000
  #   flush = 10
  #   date = [
  #   ]
  #   mailbox = 1000
  #   instance = 1
  #   fallback = "fallback-route"
  #   worker = false
  # }

  # rabbitmq {
  #   user = ""
  #   password = ""
  #   hosts = [""]
  #   port = 1024
  #   virtualHost = ""
  #   ssl = false
  #   exchange = ""
  #   routingKey = ""
  #   mode = "publish"
  #   connectionTimeout = 60
  #   interval = 1
  #   intervalMax = 60
  #   maxAttempts = -1
  #   mailbox = 1000
  #   instance = 1
  #   fallback = "fallback-route"
  #   worker = false
  # }
}

route {}

component {
  input {
    tcp = "io.techcode.logbulk.pipeline.input.TcpInput"
    exec = "io.techcode.logbulk.pipeline.input.ExecInput"
    heartbeat = "io.techcode.logbulk.pipeline.input.HeartbeatInput"
    mysql = "io.techcode.logbulk.pipeline.input.MysqlInput"
    rabbitmq = "io.techcode.logbulk.pipeline.input.RabbitMQInput"
  }

  transform {
    grok = "io.techcode.logbulk.pipeline.transform.GrokTransform"
    regex = "io.techcode.logbulk.pipeline.transform.RegexTransform"
    json = "io.techcode.logbulk.pipeline.transform.JsonTransform"
    mutate = "io.techcode.logbulk.pipeline.transform.MutateTransform"
    metric = "io.techcode.logbulk.pipeline.transform.MetricTransform"
    limiter = "io.techcode.logbulk.pipeline.transform.LimiterTransform"
  }

  output {
    elasticsearch = "io.techcode.logbulk.pipeline.output.ElasticOutput"
    mongo = "io.techcode.logbulk.pipeline.output.MongoOutput"
    rabbitmq = "io.techcode.logbulk.pipeline.output.RabbitMQOutput"
  }
}